
// Grammar inspired by the ANSI C Grammar
// See: https://www.lysator.liu.se/c/ANSI-C-grammar-y.html

%union
{
    struct decl *decl;
    struct stmt *stmt;
    struct expr *expr;
    struct param_list *param_list;
    struct type *type;
    struct symbol *symbol;
    char *name;
    int number;
    char character;
};

%{

#include <stdio.h>
#include <stdlib.h>
#include "decl.h"
#include "expr.h"
#include "param_list.h"
#include "stmt.h"
#include "symbol.h"
#include "type.h"

void yyerror (char const *msg);

/* Manually declare the interface to the scanner generated by flex. */

extern char *yytext;
extern int yylex();

extern char *strdup(const char* str);

/*
    Keep the final result of the parse in a global variable,
    so that it can be retrieved by main().
*/

struct decl * parser_result = 0;

void yyerror (char const *msg);
extern int yylex();

%}

%type <decl> program toplevel_declaration function_declaration function_prototype symbol_declaration
%type <stmt> statement statement_if statement_for statement_expression statement_print statement_return list_statement compound_statement statement_decl
%type <expr> primary_expression postfix_expression unary_expression multiplicative_expression additive_expression comparative_expression assignment_expression expression initializer list_initializer list_expression expression_optional
%type <type> type concrete_type return_type
%type <param_list> list_parameter identity
%type <name> identifier TOKEN_STRINGLITERAL
%type <number> number
%type <character> TOKEN_CHARLITERAL

%token TOKEN_ARRAY
%token TOKEN_BOOLEAN
%token TOKEN_CHAR
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FOR
%token TOKEN_FUNCTION
%token TOKEN_IF
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRING
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_WHILE
%token TOKEN_COLON
%token TOKEN_SEMICOLON
%token TOKEN_COMMA
%token TOKEN_LEFTSQUAREBRACKET
%token TOKEN_RIGHTSQUAREBRACKET
%token TOKEN_LEFTCURLYBRACE
%token TOKEN_RIGHTCURLYBRACE
%token TOKEN_LEFTPAREN
%token TOKEN_RIGHTPAREN
%token TOKEN_EQUALS
%token TOKEN_CARRET
%token TOKEN_PLUS
%token TOKEN_MINUS
%token TOKEN_PLUSPLUS
%token TOKEN_MINUSMINUS
%token TOKEN_MULTIPLY
%token TOKEN_DIVIDE
%token TOKEN_MODULO
%token TOKEN_EQUALSEQUALS
%token TOKEN_GREATERTHANEQUALTO
%token TOKEN_LESSTHANEQUALTO
%token TOKEN_LESSTHAN
%token TOKEN_GREATERTHAN
%token TOKEN_NOTEQUAL
%token TOKEN_NOT
%token TOKEN_PIPEPIPE
%token TOKEN_ANDAND
%token TOKEN_CHARLITERAL
%token TOKEN_STRINGLITERAL
%token TOKEN_NUMBER
%token TOKEN_IDENTIFIER
%token TOKEN_ERROR

%start program

%define parse.error verbose

//%locations %define api.pure

%token-table

%%

identifier
    : TOKEN_IDENTIFIER
    { $$ = strdup(yytext);}
;

number
    : TOKEN_NUMBER
    { $$ = atoi(yytext); }
;

// Literals and parenthesized grouping
primary_expression
    : identifier
    { $$ = expr_create_name($1); }
    | TOKEN_CHARLITERAL
    { $$ = expr_create_char_literal(yytext[1]); }
    | TOKEN_STRINGLITERAL
    { $$ = expr_create_string_literal(strdup(yytext)); }
    | number
    { $$ = expr_create_integer_literal($1); }
    | TOKEN_TRUE
    { $$ = expr_create_boolean_literal(1); }
    | TOKEN_FALSE
    { $$ = expr_create_boolean_literal(0); }
    | TOKEN_LEFTPAREN expression TOKEN_RIGHTPAREN  // Grouped expression (expression in here)
    { $$ = expr_create(EXPR_GROUP, $2, NULL); }
;

// f(something), a[something], c++, c--
postfix_expression
    : primary_expression
    { $$ = $1; }
    | postfix_expression TOKEN_LEFTSQUAREBRACKET expression TOKEN_RIGHTSQUAREBRACKET  // Array access A[something]
    { $$ = expr_create(EXPR_SUBSCRIPT, $1, $3); }
    | postfix_expression TOKEN_LEFTPAREN list_expression TOKEN_RIGHTPAREN             // Funciton call F(something)
    { $$ = expr_create(EXPR_CALL, $1, $3); }
    | postfix_expression TOKEN_LEFTPAREN TOKEN_RIGHTPAREN                             // Empty funciton call F()
    { $$ = expr_create(EXPR_CALL, $1, NULL); }
    | postfix_expression TOKEN_PLUSPLUS
    { $$ = expr_create(EXPR_INC, $1, NULL); }
    | postfix_expression TOKEN_MINUSMINUS
    { $$ = expr_create(EXPR_DEC, $1, NULL); }
;

// -a, !a
unary_expression
    : postfix_expression
    { $$ = $1; }
    | TOKEN_MINUS unary_expression
    { $$ = expr_create(EXPR_NEGATE, $2, NULL); }
    | TOKEN_NOT unary_expression
    { $$ = expr_create(EXPR_NOT, $2, NULL); }
;

// a ^ b, a * b, a / b, a % b
multiplicative_expression
    : unary_expression
    { $$ = $1; }
    | multiplicative_expression TOKEN_CARRET unary_expression
    { $$ = expr_create(EXPR_POW, $1, $3); }
    | multiplicative_expression TOKEN_MULTIPLY unary_expression
    { $$ = expr_create(EXPR_MUL, $1, $3); }
    | multiplicative_expression TOKEN_DIVIDE unary_expression
    { $$ = expr_create(EXPR_DIV, $1, $3); }
    | multiplicative_expression TOKEN_MODULO unary_expression
    { $$ = expr_create(EXPR_MOD, $1, $3); }
;

// a + b, a - b
additive_expression
    : multiplicative_expression
    { $$ = $1; }
    | additive_expression TOKEN_PLUS multiplicative_expression
    { $$ = expr_create(EXPR_ADD, $1, $3); }
    | additive_expression TOKEN_MINUS multiplicative_expression
    { $$ = expr_create(EXPR_SUB, $1, $3); }
;

// a < b, a <= b, a > b, a >= b, a == b, a != b, a && b, a || b
comparative_expression
    : additive_expression
    { $$ = $1; }
    | comparative_expression TOKEN_LESSTHAN additive_expression
    { $$ = expr_create(EXPR_LT, $1, $3); }
    | comparative_expression TOKEN_LESSTHANEQUALTO additive_expression
    { $$ = expr_create(EXPR_LTE, $1, $3); }
    | comparative_expression TOKEN_GREATERTHAN additive_expression
    { $$ = expr_create(EXPR_GT, $1, $3); }
    | comparative_expression TOKEN_GREATERTHANEQUALTO additive_expression
    { $$ = expr_create(EXPR_GTE, $1, $3); }
    | comparative_expression TOKEN_EQUALSEQUALS additive_expression
    { $$ = expr_create(EXPR_EQUALITY, $1, $3); }
    | comparative_expression TOKEN_NOTEQUAL additive_expression
    { $$ = expr_create(EXPR_NEQUALITY, $1, $3); }
    | comparative_expression TOKEN_ANDAND additive_expression
    { $$ = expr_create(EXPR_AND, $1, $3); }
    | comparative_expression TOKEN_PIPEPIPE additive_expression
    { $$ = expr_create(EXPR_OR, $1, $3); }
;

assignment_expression
    : comparative_expression
    { $$ = $1; }
    | assignment_expression TOKEN_EQUALS comparative_expression
    { $$ = expr_create(EXPR_ASSIGNMENT, $1, $3); }
;

expression
    : assignment_expression
    { $$ = $1; }
;

list_expression
    : expression TOKEN_COMMA list_expression
    { $$ = expr_create(EXPR_ARG, $1, $3); }
    | expression
    { $$ = expr_create(EXPR_ARG, $1, NULL); }
;

statement_if
    : TOKEN_IF TOKEN_LEFTPAREN expression TOKEN_RIGHTPAREN statement
    { $$ = stmt_create(STMT_IF, NULL, NULL, $3, NULL, $5, NULL, NULL); }
    | TOKEN_IF TOKEN_LEFTPAREN expression TOKEN_RIGHTPAREN statement TOKEN_ELSE statement
    { $$ = stmt_create(STMT_IF, NULL, NULL, $3, NULL, $5, $7, NULL); }
;

expression_optional
    : expression
    { $$ = $1; }
    | %empty
    { $$ = NULL; }
;

statement_for
    : TOKEN_FOR TOKEN_LEFTPAREN expression_optional TOKEN_SEMICOLON expression_optional TOKEN_SEMICOLON expression_optional TOKEN_RIGHTPAREN statement
    { $$ = stmt_create(STMT_FOR, NULL, $3, $5, $7, $9, NULL, NULL); }
;

statement_expression
    : expression TOKEN_SEMICOLON
    { $$ = stmt_create(STMT_EXPR, NULL, NULL, $1, NULL, NULL, NULL, NULL); }
;

statement_print
    : TOKEN_PRINT list_expression TOKEN_SEMICOLON
    { $$ = stmt_create(STMT_PRINT, NULL, NULL, $2, NULL, NULL, NULL, NULL); }
    | TOKEN_PRINT TOKEN_SEMICOLON
    { $$ = stmt_create(STMT_PRINT, NULL, NULL, NULL, NULL, NULL, NULL, NULL); }
;

statement_return
    : TOKEN_RETURN expression TOKEN_SEMICOLON
    { $$ = stmt_create(STMT_RETURN, NULL, NULL, $2, NULL, NULL, NULL, NULL); }
;

statement_decl
    : symbol_declaration TOKEN_SEMICOLON
    { $$ = stmt_create(STMT_DECL, $1, NULL, NULL, NULL, NULL, NULL, NULL); }

statement
    : statement_if
    { $$ = $1; }
    | statement_for
    { $$ = $1; }
    | statement_expression
    { $$ = $1; }
    | statement_decl
    { $$ = $1; }
    | statement_print
    { $$ = $1; }
    | statement_return
    { $$ = $1; }
    | compound_statement
    { $$ = $1; }
;

list_statement
    : statement list_statement
    { $$ = $1; $1->next = $2; }
    | statement
    { $$ = $1; }
;

compound_statement
    : TOKEN_LEFTCURLYBRACE TOKEN_RIGHTCURLYBRACE
    { $$ = NULL; }
    | TOKEN_LEFTCURLYBRACE list_statement TOKEN_RIGHTCURLYBRACE
    {
        // This code is needed to resolve nested code blocks
        // It appends STMT_BLOCKSTART and STMT_BLOCKEND statements to resolve scoping issues down the line during semantic analysis

        $$ = stmt_create(STMT_BLOCKSTART, 0, 0, 0, 0, 0, 0, $2);

        struct stmt *n = $2;
        
        while(n->next != NULL)
            n = n->next;
        
        n->next = stmt_create(STMT_BLOCKEND, 0, 0, 0, 0, 0, 0, 0);
    }
;

concrete_type
    : TOKEN_INTEGER
    { $$ = type_create(TYPE_INTEGER, NULL, NULL); }
    | TOKEN_STRING
    { $$ = type_create(TYPE_STRING, NULL, NULL); }
    | TOKEN_CHAR
    { $$ = type_create(TYPE_CHARACTER, NULL, NULL); }
    | TOKEN_BOOLEAN
    { $$ = type_create(TYPE_BOOLEAN, NULL, NULL); }
;

// Types are either concrete, or a composition of array modifiers and concrete types
type
    : concrete_type
    { $$ = $1; }
    | TOKEN_ARRAY TOKEN_LEFTSQUAREBRACKET TOKEN_RIGHTSQUAREBRACKET type
    { $$ = type_create(TYPE_ARRAY, $4, NULL); }
    | TOKEN_ARRAY TOKEN_LEFTSQUAREBRACKET number TOKEN_RIGHTSQUAREBRACKET type
    { $$ = type_create(TYPE_ARRAY, $5, NULL); $$->size = $3; }
;

// Return types are the only type allowed to be void
return_type
    : type
    { $$ = $1; }
    | TOKEN_VOID
    { $$ = type_create(TYPE_VOID, NULL, NULL); }
;

list_initializer
    : initializer TOKEN_COMMA list_initializer
    { $$ = $1; $1->right = $3; }
    | initializer
    { $$ = $1; }
;

initializer
    : TOKEN_LEFTCURLYBRACE list_expression TOKEN_RIGHTCURLYBRACE
    { $$ = expr_create(EXPR_INITIALIZER, $2, NULL); }
    | TOKEN_LEFTCURLYBRACE list_initializer TOKEN_RIGHTCURLYBRACE
    { $$ = expr_create(EXPR_INITIALIZER, $2, NULL); }
    | TOKEN_LEFTCURLYBRACE TOKEN_RIGHTCURLYBRACE
    { $$ = expr_create(EXPR_INITIALIZER, NULL, NULL); }
;

symbol_declaration
    : identifier TOKEN_COLON type
    { $$ = decl_create($1, $3, NULL, NULL, NULL); }
    | identifier TOKEN_COLON type TOKEN_EQUALS expression
    { $$ = decl_create($1, $3, $5, NULL, NULL); }
    | identifier TOKEN_COLON type TOKEN_EQUALS initializer
    { $$ = decl_create($1, $3, $5, NULL, NULL); }
;

identity
    : identifier TOKEN_COLON type
    { $$ = param_list_create($1, $3, NULL); }
;

list_parameter
    : identity TOKEN_COMMA list_parameter
    { $$ = $1; $1->next = $3; }
    | identity
    { $$ = $1; }
;

function_declaration
    : identifier TOKEN_COLON TOKEN_FUNCTION return_type TOKEN_LEFTPAREN TOKEN_RIGHTPAREN TOKEN_EQUALS compound_statement
    { $$ = decl_create($1, type_create(TYPE_FUNCTION, $4, NULL), NULL, $8, NULL); }
    | identifier TOKEN_COLON TOKEN_FUNCTION return_type TOKEN_LEFTPAREN list_parameter TOKEN_RIGHTPAREN TOKEN_EQUALS compound_statement
    { $$ = decl_create($1, type_create(TYPE_FUNCTION, $4, $6), NULL, $9, NULL); }
;

function_prototype
    : identifier TOKEN_COLON TOKEN_FUNCTION return_type TOKEN_LEFTPAREN TOKEN_RIGHTPAREN
    { $$ = decl_create($1, type_create(TYPE_FUNCTION, $4, NULL), NULL, NULL, NULL); }
    | identifier TOKEN_COLON TOKEN_FUNCTION return_type TOKEN_LEFTPAREN list_parameter TOKEN_RIGHTPAREN
    { $$ = decl_create($1, type_create(TYPE_FUNCTION, $4, $6), NULL, NULL, NULL); }
;

toplevel_declaration
    : symbol_declaration TOKEN_SEMICOLON
    { $$ = $1; }
    | function_declaration
    { $$ = $1; }
    | function_prototype TOKEN_SEMICOLON 
    { $$ = $1; }
;

program
    : toplevel_declaration
    { parser_result = $1; }
    | toplevel_declaration program
    { parser_result = $1; $1->next = $2; }
    | %empty
    { parser_result = NULL; }
;

%%

// See: https://stackoverflow.com/a/32448812
// Allows for the token integer representation to be translated to a string literal
const char* token_name(enum yytokentype t) {
    return yytname[YYTRANSLATE(t)];
}

void yyerror (char const *msg) {
    printf("parse error: %s\n", msg);
}

//void yyerror (YYLTYPE *locp, char const *msg)
//{
//    printf("parse error: %s\n", msg);
//    printf("\tfirst_line=%d\n", locp->first_line);
//    printf("\tfirst_column=%d\n", locp->first_column);
//    printf("\tlast_line=%d\n", locp->last_line);
//    printf("\tlast_column=%d\n", locp->last_column);
//}
